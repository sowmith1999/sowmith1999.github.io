<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on SowmithK</title>
    <link>http://localhost:1313/blog/</link>
    <description>Recent content in Blog on SowmithK</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Dec 2024 00:57:38 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Markov Chains &amp; Modelling</title>
      <link>http://localhost:1313/blog/2024/markov-chains-modelling/</link>
      <pubDate>Sat, 21 Dec 2024 00:57:38 -0500</pubDate>
      <guid>http://localhost:1313/blog/2024/markov-chains-modelling/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been hearing of Markov Chains for a few years, never got to read about them or something with them. This is my look at them. The sole goal of this post is to get a good look at how Markov Chains work, we are going to do this by attempting to model some stock data. This post is initially written as a paper for a course I took.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;There are a myriad of ways to model stock, and lot of good research is being done to solve this problem, and the better the algorithm to predict stock, the more money you can make and that can be a great motivator to innovate and have better stock prediction models. These industry models can be extremely complex and use proprietary heuristics that involve working with several different types of models. For our paper, we are not involving any external factors to base the predictions on, and not using macro economic trends or factors. and we are going to use only the candle data that we can fetch about a stock.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Souffle Auto Index</title>
      <link>http://localhost:1313/blog/2024/souffle-auto-index/</link>
      <pubDate>Fri, 14 Jun 2024 10:57:38 -0500</pubDate>
      <guid>http://localhost:1313/blog/2024/souffle-auto-index/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Datalog&#34;&gt;Datalog&lt;/a&gt; rules are a bunch of relational queries, each involving of joins over multiple relations. Here is a simple example of a Datalog rule:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&#xA;&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-prolog&#34; data-lang=&#34;prolog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;y&lt;/span&gt;) :- &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;z&lt;/span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;edge&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;z&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;y&lt;/span&gt;).&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;The above query does Transitive closure over a graph, where &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;edge&lt;/code&gt; are relations. The query is saying, if there is a path from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; and there is an edge from &lt;code&gt;z&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;, then there is a path from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;. This query involves a join over &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;edge&lt;/code&gt; relations. &lt;a href=&#34;https://github.com/harp-lab/brouhaha/blob/master/analyze.slog&#34;&gt;Larger programs&lt;/a&gt; can have 100&amp;rsquo;s of such queries, each involving joins over multiple relations.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
